import numpy as np
import matplotlib.pyplot as plt
from scipy.stats import expon, poisson, kstest, chisquare
import streamlit as st

# Функция для генерации пуассоновских потоков
def generate_poisson_process(lmbda, T, size=500):
    inter_arrival_times = -np.log(np.random.rand(size)) / lmbda
    event_times = np.cumsum(inter_arrival_times)
    return event_times[event_times <= T]

# Функция для построения графиков
def plot_processes(lmbda1, lmbda2, T, num_realizations=50):
    fig, axes = plt.subplots(1, 3, figsize=(15, 6))

    # Генерация пуассоновских потоков
    events1 = [generate_poisson_process(lmbda1, T) for _ in range(num_realizations)]
    events2 = [generate_poisson_process(lmbda2, T) for _ in range(num_realizations)]
    
    # Суммируем два пуассоновских потока
    sum_events = [np.sort(np.concatenate([e1, e2])) for e1, e2 in zip(events1, events2)]

    # Построение графиков потоков
    for e in events1:
        axes[0].step(e, np.arange(1, len(e) + 1), where='post', alpha=0.3)
    axes[0].set_title(f'Пуассоновский поток λ1={lmbda1}')
    
    for e in events2:
        axes[1].step(e, np.arange(1, len(e) + 1), where='post', alpha=0.3)
    axes[1].set_title(f'Пуассоновский поток λ2={lmbda2}')
    
    for e in sum_events:
        axes[2].step(e, np.arange(1, len(e) + 1), where='post', alpha=0.3)
    axes[2].set_title('Сумма пуассоновских потоков')

    plt.tight_layout()
    return fig, events1, events2, sum_events

# Функция для расчета статистических характеристик
def compute_statistics(events, lmbda, T):
    counts = np.array([len(e) for e in events])
    
    # Вычисление теоретических и эмпирических параметров
    empirical_lambda = np.mean(counts) / T
    empirical_var = np.var(counts)
    theoretical_var = lmbda * T

    # KS-тест
    inter_arrival_times = np.concatenate([np.diff(e) for e in events if len(e) > 1])
    ks_stat, ks_pvalue = kstest(inter_arrival_times, 'expon', args=(0, 1/lmbda))
    
    # χ²-тест
    max_count = max(counts)
    expected_counts = poisson(lmbda * T).pmf(np.arange(0, max_count + 1)) * len(events)
    
    # Приведение массивов к одинаковой длине
    observed_counts = np.bincount(counts, minlength=len(expected_counts))
    expected_counts = expected_counts[:len(observed_counts)]
    
    # Нормализация
    expected_counts *= observed_counts.sum() / expected_counts.sum()

    chi2_stat, chi2_pvalue = chisquare(observed_counts, f_exp=expected_counts)

    return {
        'empirical_lambda': empirical_lambda,
        'theoretical_var': theoretical_var,
        'empirical_var': empirical_var,
        'ks_stat': ks_stat,
        'ks_pvalue': ks_pvalue,
        'chi2_stat': chi2_stat,
        'chi2_pvalue': chi2_pvalue
    }

def main():
    
    # Пользовательский ввод
    N = st.number_input("Введите значение N", value=14)

    # Промежуток наблюдения
    T1 = N
    T2 = N + 100
    T = T2 - T1  # Время наблюдения

    # Параметры потоков
    lmbda1 = (N + 8) / (N + 24)  # Интенсивность первого потока
    lmbda2 = (N + 9) / (N + 25)  # Интенсивность второго потока

    num_realizations = 50  # Количество реализаций

    # Инициализация счётчиков в состоянии сессии
    if 'confirmed_count' not in st.session_state:
        st.session_state.confirmed_count = 0
    if 'rejected_count' not in st.session_state:
        st.session_state.rejected_count = 0
    total_runs = 100

    # Чекбокс для отображения графиков
    show_plots = st.checkbox("Показать графики генерации потоков", value=True)

    # Инициализация статус-бара
    progress_bar = st.progress(0)

    # Инициализация состояния сессии для хранения графиков
    if 'plots' not in st.session_state:
        st.session_state.plots = []
    if 'stats' not in st.session_state:
        st.session_state.stats = []

    # Генерация графиков и статистики только при первом запуске
    if len(st.session_state.plots) == 0:
        for run in range(total_runs):
            # Визуализация потоков
            if show_plots:
                fig, events1, events2, sum_events = plot_processes(lmbda1, lmbda2, T, num_realizations)
                st.session_state.plots.append(fig)

            # Расчет статистических характеристик для каждого потока
            stats1 = compute_statistics(events1, lmbda1, T)
            stats2 = compute_statistics(events2, lmbda2, T)
            stats_sum = compute_statistics(sum_events, lmbda1 + lmbda2, T)
            st.session_state.stats.append((stats1, stats2, stats_sum))

            # Определение подтверждённых и отвергнутых теорий
            if stats1['ks_pvalue'] > 0.05 and stats2['ks_pvalue'] > 0.05:
                st.session_state.confirmed_count += 1
            else:
                st.session_state.rejected_count += 1

            # Обновление статус-бара
            progress_bar.progress((run + 1) / total_runs)

    # Выбор цикла для отображения графика
    selected_run = st.selectbox("Выберите цикл для отображения графика", range(total_runs))
    
    if show_plots and selected_run < len(st.session_state.plots):
        st.pyplot(st.session_state.plots[selected_run])  # Отображение выбранного графика

    # Получаем статистику для выбранного цикла
    if selected_run < len(st.session_state.stats):
        stats1, stats2, stats_sum = st.session_state.stats[selected_run]

    # Добавляем определение подтверждённых и отвергнутых теорий для выбранного 
    
    is_theory_confirmed1 = stats1['ks_pvalue'] > 0.05
    is_theory_confirmed2 = stats2['ks_pvalue'] > 0.05
    is_theory_confirmed_sum = stats_sum['ks_pvalue'] > 0.05

    # Определение подтверждённых и отвергнутых теорий
    if stats1['ks_pvalue'] > 0.05 and stats2['ks_pvalue'] > 0.05 and stats1['chi2_pvalue'] > 0.05 and stats2['chi2_pvalue'] > 0.05:
        st.session_state.confirmed_count += 1
    else:
        st.session_state.rejected_count += 1

    # Вывод результатов
    stats1, stats2, stats_sum = st.session_state.stats[selected_run]

    st.subheader("Статистика для процесса с λ1={:.2f}".format(lmbda1))
    st.markdown(f"""
    - **Эмпирическая интенсивность λ**: {stats1['empirical_lambda']:.4f}
    - **Теоретическая дисперсия**: {stats1['theoretical_var']:.4f}
    - **Эмпирическая дисперсия**: {stats1['empirical_var']:.4f}
    - **Статистика Колмогорова-Смирнова**: {stats1['ks_stat']:.4f}
    - **p-значение Колмогорова-Смирнова**: {stats1['ks_pvalue']:.4f}
    - **Статистика χ²**: {stats1['chi2_stat']:.4f}
    - **p-значение χ²**: {stats1['chi2_pvalue']:.4f}
    - **Теория подтверждена**: {"Да" if is_theory_confirmed1 else "Нет"}
    - **Теория подтверждена по χ²**: {"Да" if stats1['chi2_pvalue'] > 0.05 else "Нет"}
    """)

    st.subheader("Статистика для процесса с λ2={:.2f}".format(lmbda2))
    st.markdown(f"""
    - **Эмпирическая интенсивность λ**: {stats2['empirical_lambda']:.4f}
    - **Теоретическая дисперсия**: {stats2['theoretical_var']:.4f}
    - **Эмпирическая дисперсия**: {stats2['empirical_var']:.4f}
    - **Статистика Колмогорова-Смирнова**: {stats2['ks_stat']:.4f}
    - **p-значение Колмогорова-Смирнова**: {stats2['ks_pvalue']:.4f}
    - **Статистика χ²**: {stats2['chi2_stat']:.4f}
    - **p-значение χ²**: {stats2['chi2_pvalue']:.4f}
    - **Теория подтверждена**: {"Да" if is_theory_confirmed2 else "Нет"}
    - **Теория подтверждена по χ²**: {"Да" if stats1['chi2_pvalue'] > 0.05 else "Нет"}
    """)

    st.subheader("Статистика для суммы процессов (λ1 + λ2)")
    st.markdown(f"""
    - **Эмпирическая интенсивность λ**: {stats_sum['empirical_lambda']:.4f}
    - **Теоретическая дисперсия**: {stats_sum['theoretical_var']:.4f}
    - **Эмпирическая дисперсия**: {stats_sum['empirical_var']:.4f}
    - **Статистика Колмогорова-Смирнова**: {stats_sum['ks_stat']:.4f}
    - **p-значение Колмогорова-Смирнова**: {stats_sum['ks_pvalue']:.4f}
    - **Статистика χ²**: {stats_sum['chi2_stat']:.4f}
    - **p-значение χ²**: {stats_sum['chi2_pvalue']:.4f}
    - **Теория подтверждена**: {"Да" if is_theory_confirmed_sum else "Нет"}
    - **Теория подтверждена по χ²**: {"Да" if stats1['chi2_pvalue'] > 0.05 else "Нет"}
    """)

    # Вывод общей статистики
    st.subheader("Общая статистика")
    st.markdown(f"""
    - **Подтвержденные теории**: {st.session_state.confirmed_count}
    - **Отвергнутые теории**: {st.session_state.rejected_count}
    - **Всего запусков**: {total_runs}
    """)

if __name__ == "__main__":
    st.title("Моделирование пуассоновских потоков")
    main()


# Как генерируются пуассоновские потоки?

# Пуассоновский поток — это последовательность случайных событий, происходящих в некоторый момент времени. Время между событиями (интервалы) имеет экспоненциальное распределение с параметром λ — интенсивностью потока. Для генерации пуассоновских потоков:
# 1. Генерируются интервалы между событиями: время ожидания до следующего события экспоненциально распределено (Expon(λ)). Для генерации этих интервалов используется формула:
#     interval = -1 / λ * ln(U),
#     где U — равномерно распределённая случайная величина на отрезке [0, 1].
# 2. Накопление событий во времени: суммируются интервалы между событиями для получения момента каждого события. Генерированные интервалы добавляются к текущему времени, пока не достигнут конца наблюдаемого промежутка.

# Определение и свойства пуассоновских потоков

# Пуассоновский поток описывает случайный процесс, при котором события происходят независимо друг от друга с постоянной интенсивностью λ.

# Основные свойства:
# 1. Отсутствие памяти: вероятность того, что событие произойдет в ближайший момент времени, не зависит от того, когда произошло последнее событие.
# 2. Независимость событий: количество событий в непересекающихся промежутках времени — независимые случайные величины.
# 3. Гомогенность: вероятность появления события в малом интервале времени Δt примерно равна λΔt, где λ — интенсивность потока.

# Распределение величины потока

# Количество событий N(T), произошедших за фиксированное время T, имеет пуассоновское распределение с параметром λT:
#     P(N(T) = k) = (λT)^k * e^(-λT) / k! ,  k = 0, 1, 2, ...

# где:
# - λ — интенсивность потока (среднее число событий в единицу времени),
# - T — период времени наблюдения.
# Это означает, что вероятность появления точно k событий за время T описывается этой формулой.

# Математическое ожидание и дисперсия пуассоновского потока

# Математическое ожидание (среднее количество событий) для пуассоновского потока равно:
#     E[N(T)] = λT.

# Дисперсия числа событий за время T также равна λT:
#     Var(N(T)) = λT.

# Это важное свойство пуассоновского процесса: среднее значение и дисперсия числа событий одинаковы.

# Оценка интенсивности

# Чтобы оценить интенсивность λ по наблюдениям, можно использовать эмпирическую оценку интенсивности:
#     λ^ = Σ N(T_i) / (nT),
# где N(T_i) — число событий за время T_i, n — количество наблюдений.

# Вероятность в пуассоновском потоке

# Вероятность того, что произойдет k событий за время T, определяется пуассоновским распределением. Вероятность появления хотя бы одного события на малом промежутке времени Δt приблизительно равна λΔt. Для небольших Δt вероятность более чем одного события очень мала.

# Смысл χ²-статистики

# Статистика χ² используется для проверки гипотезы о том, что наблюдаемые частоты событий соответствуют ожидаемым (теоретическим) частотам для пуассоновского распределения.

# Шаги проведения теста:
# 1. Наблюдаемые частоты: подсчитываются фактические частоты количества событий в разных интервалах времени.
# 2. Ожидаемые частоты: вычисляются по формуле пуассоновского распределения с параметром λ.
# 3. χ²-статистика:
#     χ² = Σ ((O_i - E_i)² / E_i),
# где O_i — наблюдаемые частоты, E_i — ожидаемые частоты.

# Если χ²-статистика мала, то гипотеза о том, что наблюдения соответствуют пуассоновскому распределению, подтверждается.

# Основная задача лабораторной работы

# Основная задача ЛР — исследовать пуассоновские потоки и их характеристики, проверить гипотезы о распределении времени между событиями (экспоненциальное) и числе событий (пуассоновское распределение), используя статистические методы (тесты Колмогорова-Смирнова и χ²).

# Практические частоты

# Практические частоты — это фактически наблюдаемые числа событий за время T. Они сравниваются с ожидаемыми частотами, вычисленными с использованием пуассоновского распределения для проверки соответствия модели и реальных данных.



# ИНФА ПО КОДУ:

# Генерация Пуассоновского Процесса
# Для генерации пуассоновского процесса используется формула интервалов между событиями, которая определяется как:
# Интервал между событиями: T = -ln(U) / λ, где:
# - U — случайная величина, равномерно распределенная на [0, 1]
# - λ — интенсивность потока (среднее количество событий на единицу времени)

# Визуализация Пуассоновских Потоков

# Пуассоновский поток отображается на графике с помощью лестничной диаграммы (step plot), где ось X — это время событий, а ось Y — это число накопленных событий.
# Для отображения двух независимых потоков с различными интенсивностями и их суммы используется функция step(), которая строит графики по каждому потоку.

# Сумма Пуассоновских Потоков

# Суммирование пуассоновских потоков с интенсивностями λ₁ и λ₂ даёт новый поток с интенсивностью:
# λ_sum = λ₁ + λ₂

# Статистика Пуассоновских Потоков

# Эмпирическая интенсивность пуассоновского потока определяется как:
# λ_empirical = N_events / T, где:
# - N_events — количество событий за период наблюдения
# - T — время наблюдения

# Теоретическая дисперсия пуассоновского потока: Var_theoretical = λ * T

# Эмпирическая дисперсия вычисляется на основе числа событий в разных реализациях процесса.

# Тест Колмогорова-Смирнова

# Тест Колмогорова-Смирнова используется для проверки гипотезы о том, что интервалы между событиями распределены экспоненциально с параметром λ.
# Проверяемая гипотеза: интервалы между событиями следуют распределению Exp(λ), где Exp(λ) — экспоненциальное распределение с параметром λ.

# Тест χ²

# Тест χ² используется для сравнения распределения числа событий с теоретическим распределением Пуассона.
# Статистика χ² определяется как сумма отклонений фактических и ожидаемых значений по формуле:

# χ² = Σ (O_i - E_i)² / E_i, где:

# - O_i — наблюдаемое количество событий
# - E_i — ожидаемое количество событий согласно распределению Пуассона

# Общая Статистика
# На основе статистических тестов определяется, подтверждаются ли теории о том, что процесс является пуассоновским, и проводятся оценки соответствия данных теоретическим предположениям.